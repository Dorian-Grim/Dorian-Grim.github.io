[{"question": " Se d\u0103 urm\u0103torul algoritm:\n\n  for i = 1, n\npoz[i] = 1\nendfor\nfor i = 1, n - 1\nfor j = i + 1, n\nif x[j] < x[i] then poz[i] = poz[i] + 1\nelse poz[j] = poz[j] + 1\n\nendfor\n\nendfor\n\nendif\n\n\u0218tiind c\u0103 datele de intrare sunt n = 7 \u0219i vectorul x = (9, 15, 23, 2, 5, 4, 8) care vor fi valorile vectorului poz la sf\u00e2r\u0219itul algoritmului ?\n", "answers": ["(5, 6, 7, 1, 2, 3, 4)\n", " (5, 6, 7, 1, 3, 2, 4)\n", "(6, 5, 7, 1, 2, 3, 4)\n", "(1, 2, 3, 4, 5, 6, 7)"], "correct_answers": [1]}, {"question": " Se d\u0103 urm\u0103toarea func\u021bie recursiv\u0103\n1) int inaltime(NodArb * rad)\n2) // returneaza inaltimea unui arbore binar\n3) {\n  4) if (rad == NULL) return 0;\n5)...............................................................................................\n6) return 1 + max(inaltime(rad -> stang), inaltime(rad -> drept));\n7)\n8)\n}\nCe instruc\u021biuni trebuie scrise \u00een linia de cod 5) pentru ca func\u021bia s\u0103 returneze \u00een\u0103l\u021bimea unui arbore binar ?\n", "answers": ["instruc\u021biunea vid\u0103\n", "int inaltime = 0;\n", "\n  else if (rad -> stang == NULL && rad -> drept == NULL) return 0;\n", "else"], "correct_answers": [2]}, {"question": " Se d\u0103 urm\u0103toarea func\u021bie\nint cautare(int x[], int first, int last, int value) {\n  int mid;\n  if (first > last) return -1;\n  mid = (first + last) / 2;\n  if (x[mid] == value) return mid;\n  if (x[mid] < value) return cautare(x, mid + 1, last, value);\n  else return cautare(x, first, mid - 1, value);\n}\nDac\u0103 vectorul x = (2, 4, 5, 8, 9, 15, 23), care va fi rezultatul apel\u0103rii func\u021biei cautare(x, 2, 6, 8) ?\n", "answers": [" - 1\n", "2\n", " 3\n", "1\n"], "correct_answers": [2]}, {"question": " Parcurgerea \u00een preordine a arborelui binar din Fig.1 va afi\u0219a\n\nFig.1\n", "answers": ["10, 4, 1, 9, 21, 15, 28, 23\n", "10, 4, 1, 9, 23, 21, 28, 15\n", "1, 4, 9, 10, 15, 21, 23, 28\n", " 10, 4, 1, 9, 21, 15, 23, 28"], "correct_answers": [3]}, {"question": " Parcurgerea \u00een inordine a arborelui binar din Fig.1 va afi\u0219a\n", "answers": ["10, 4, 1, 9, 21, 15, 23, 28\n", " 1, 4, 9, 10, 15, 21, 23, 28\n", "1, 4, 9, 10, 15, 21, 28, 23\n", "1, 4, 9, 10, 21, 23, 28, 15"], "correct_answers": [1]}, {"question": " Parcurgerea \u00een postordine a arborelui binar din Fig.1 va afi\u0219a\n", "answers": ["1, 4, 9, 10, 15, 21, 23, 28\n", "1, 4, 9, 10, 15, 21, 28, 23\n", " 1, 9, 4, 15, 28, 23, 21, 10\n", "1, 9, 4, 15, 23, 28, 21, 10"], "correct_answers": [2]}, {"question": " Ce returneaz\u0103 urm\u0103toarea func\u021bie dac\u0103 rad este pointer la r\u0103d\u0103cina unui arbore binar nenul ? int fct(NodArb * rad) {\n  if (rad == NULL) return 0;\n  return 1 + fct(rad -> stang) + fct(rad -> drept);\n}\n\n", "answers": ["0\n", "1\n", "num\u0103rul de noduri terminale ale arborelui\n", " num\u0103rul de noduri ale arborelui."], "correct_answers": [3]}, {"question": " Ordinul de complexitate a algoritmului Bubblesort(metoda bulelor) este\n", "answers": ["O(n)\n", " O(n2)\n", "O(n log n)\n", "O(n3)\n"], "correct_answers": [1]}, {"question": " Cel mai r\u0103u caz pentru algoritmul de sortare rapid\u0103 este cazul \u00een care\n", "answers": [" vectorul este deja sortat\n", "vectorul nu este creat aleator\n", "toate elementele vectorului sunt pare\n", "vectorul con\u021bine \u0219i elemente negative"], "correct_answers": [0]}, {"question": " C\u00e2te compara\u021bii se fac dac\u0103 se folose\u0219te algoritmul de c\u0103utare secven\u021bial\u0103 pentru c\u0103utarea elementului 12 \u00een vectorul(2, 3, 6, 9, 10, 25) ?\n", "answers": ["6\n", "5\n", "3\n", "1"], "correct_answers": []}, {"question": " C\u00e2te compara\u021bii se fac dac\u0103 se folose\u0219te algoritmul de c\u0103utare binar\u0103 pentru c\u0103utarea elementului 12 \u00een vectorul(2, 3, 6, 9, 10, 25) ?\n", "answers": ["6\n", "5\n", "3\n", "1"], "correct_answers": []}, {"question": " O list\u0103 liniar\u0103 \u00een care inser\u0103rile \u00een lista se fac pe la un cap\u0103t, iar \u0219tergerile pe la cel\u0103lalt cap\u0103t se nume\u0219te\n", "answers": ["stiv\u0103\n", "vector\n", " coad\u0103\n", "arbore"], "correct_answers": [2]}, {"question": " Care din urm\u0103torii algoritmi au ordinul de complexitate O(n log n) ?\n", "answers": ["Bubblesort(sortarea cu metoda bulelor)\n", " Mergesort(sortarea prin interclasare)\n", "sortarea prin inserare\n", " Quicksort(sortarea rapid\u0103)."], "correct_answers": [1, 3]}, {"question": " Cel mai r\u0103u caz pentru algoritmul de c\u0103utare secven\u021bial\u0103 este cazul \u00een care\n", "answers": ["elementul c\u0103utat este la mijlocul listei\n", " elementul c\u0103utat nu se afl\u0103 \u00een list\u0103\n", " elementul c\u0103utat este pe ultima pozi\u021bie \u00een list\u0103\n", "vectorul este ordonat crescator"], "correct_answers": [1, 2]}, {"question": " Timpul de execu\u021bie al unui algoritm se m\u0103soar\u0103 \u00een\n", "answers": ["num\u0103rul de kilocte\u021bi necesari\n", "num\u0103rul de instruc\u021biuni ale algoritmului\n", " num\u0103rul de opera\u021bii cheie\n", "num\u0103rul de milisecunde necesar execut\u0103rii."], "correct_answers": [2]}, {"question": " Ordinul de complexitate a algoritmului de c\u0103utare binar\u0103 este\n", "answers": ["O(n)\n", "O(n2)\n", "O(n log n)\n", " O(log n)"], "correct_answers": [3]}, {"question": " O problem\u0103 se poate rezolva prin trei algoritmi, unul cu ordinul de complexitate O(n), altul cu ordinul O(log n) \u0219i al treilea cu ordinul O(n log n).Care este cel mai bun ?\n\n", "answers": ["cel cu ordinul O(n)\n", " cel cu ordinul O(log n)\n", "cel cu ordinul O(n log n)\n", "Toate sunt la fel."], "correct_answers": [1]}, {"question": " Se d\u0103 urm\u0103torul algoritm:\n\n  for i = 1, n - 1 index_min = i\nfor j = i + 1, n\nif x[index_min] > x[j] then index_min = j endif\nendfor\nif i\uf0b9 index_min then\ntemp = x[i] x[i] = x[index_min] x[index_min] = temp\nendif endfor\n\nCare vor fi valorile vectorului x dup\u0103 terminarea pasului i = 3 \u0219tiind c\u0103 la intrare avem valorile n = 7 \u0219i vectorul x = (9, 15, 23, 2, 5, 4, 8) ?\n", "answers": ["(2, 4, 5, 9, 15, 23, 8)\n", "(2, 5, 9, 15, 23, 4, 8)\n", "(2, 5, 9, 15, 4, 23, 8)\n", " (2, 4, 5, 9, 23, 15, 8)\n"], "correct_answers": [3]}, {"question": " Se d\u0103 urm\u0103torul algoritm.Care vor fi valorile vectorului x dup\u0103 terminarea pasului i = 5, \u0219tiind c\u0103 la intrare avem valorile n = 7 \u0219i x = (9, 15, 23, 2, 5, 4, 8) ?\n  for i = 2, n\nelem = x[i] j = i - 1\nwhile j >= 1 and x[j] > x[i] j = j\u2013 1\nendwhile pozitie = j + 1\nfor j = i, pozitie + 1, -1\nx[j] = x[j - 1]\nendfor\nx[pozitie] = elem\nendfor\n", "answers": ["(2, 4, 5, 9, 15, 23, 8)\n", " (2, 5, 9, 15, 23, 4, 8)\n", "(2, 5, 9, 15, 4, 23, 8)\n", "(2, 4, 5, 8, 9, 15, 23)\n"], "correct_answers": [1]}, {"question": " Se consider\u0103 urm\u0103toarea secven\u021b\u0103 de opera\u021bii \u00eentr - o stiv\u0103: push(2), push(10), push(8), pop(), push(9), push(6), pop(), pop(), push(7), push(3), pop(), pop(), pop(), pop().\u00cen ce ordine vor fi scoase din stiv\u0103 elementele ? (push = inserare, pop = \u0219tergere)\n", "answers": ["(2, 10, 8, 9, 6, 7, 3)\n", "(3, 7, 6, 9, 8, 10, 2)\n", " (8, 6, 9, 3, 7, 10, 2)\n", "(6, 9, 3, 7, 8, 10, 2)"], "correct_answers": [2]}, {"question": " Se consider\u0103 urm\u0103toarea secven\u021b\u0103 de opera\u021bii \u00eentr - o coad\u0103: enqueue(2), enqueue(10), enqueue(8), dequeue(), enqueue(9), enqueue(6), dequeue(), dequeue(), enqueue(7), enqueue(3), dequeue(), dequeue(), dequeue(), dequeue().\u00cen ce ordine vor fi scoase din coad\u0103 elementele ? (enqueue = inserare, dequeue = \u0219tergere)\n", "answers": [" (2, 10, 8, 9, 6, 7, 3)\n", "(3, 7, 6, 9, 8, 10, 2)\n", "(8, 6, 9, 3, 7, 10, 2)\n", "(6, 9, 3, 7, 8, 10, 2)"], "correct_answers": [0]}, {"question": " Se consider\u0103 urm\u0103toarea func\u021bie care caut\u0103 o valoare dat\u0103 \u00eentr - o list\u0103 \u00eenl\u0103n\u021buit\u0103.val este variabila a c\u0103rei valoare este c\u0103utat\u0103, iar head este un pointer la capul listei \u00een care se face c\u0103utarea.\n1) NOD * cauta(NOD * head, int val)\n2) {\n  3) NOD * iter = head;\nint gasit = 0;\n4) while ()\n  5) {\n  6) if (iter -> info == val) gasit = 1;\n7)\nelse iter = iter -> link;\n8)\n}\n9) if (gasit) return iter;\n10)\nelse return NULL;\n11)\n}\n\nCum trebuie completat\u0103 linia de cod 4 astfel \u00eenc\u00e2t func\u021bia s\u0103 ruleze corect \u0219i s\u0103 returneze un pointer la nodul cu valoarea c\u0103utat\u0103 sau NULL dac\u0103 valoarea nu a fost g\u0103sit\u0103 \u00een list\u0103 ?\n", "answers": ["  !gasit && iter != NULL\n", "!gasit\n", " iter != NULL && !gasit\n", "gasit == 0"], "correct_answers": [0, 2]}, {"question": " Se consider\u0103 urm\u0103toarea func\u021bie care are drept variabil\u0103 de intrare un pointer la capul unei liste \u00eenl\u0103n\u021buite.Ce face aceast\u0103 func\u021bie ?\n  1) NOD * fct(NOD * head)\n2) {\n  3) if (head == NULL) return NULL;\n4) head = head -> link;\n5) return head;\n6)\n}\n", "answers": ["returneaz\u0103 NULL\n", "returneaz\u0103 un pointer la capul listei\n\n", " elimin\u0103 primul nod al listei \u0219i returneaz\u0103 un pointer la noul cap al listei\n", " returneaz\u0103 NULL dac\u0103 lista este vid\u0103"], "correct_answers": [2, 3]}, {"question": " Cel mai r\u0103u caz pentru algoritmul de sortare prin selec\u021bie este cazul \u00een care\n", "answers": ["vectorul este ordonat descresc\u0103tor\n", "cel mai mare element al vectorului se afl\u0103 \u00een prima pozi\u021bie \u00een vector\n", " nu exist\u0103 un cel mai r\u0103u caz\n", "vectorul este ordonat cresc\u0103tor"], "correct_answers": [2]}, {"question": " Cel mai bun caz pentru algoritmul de sortare prin metoda bulelor(Bubblesort) este cazul \u00een care\n", "answers": ["cel mai mic element al vectorului se afl\u0103 pe prima pozi\u021bie \u00een vector\n", "cel mai mare element al vectorului se afl\u0103 \u00een ultima pozi\u021bie \u00een vector\n", "nu exist\u0103 un cel mai bun caz\n", " vectorul este ordonat cresc\u0103tor"], "correct_answers": [3]}, {"question": " Se consider\u0103 lista \u00eenl\u0103n\u021buit\u0103 cu elemente numere \u00eentregi din Fig.2:\n\n  Fig.2\nDat\u0103 urm\u0103toarea defini\u021bie a tipului de date ce corespunde unui nod al listei, struct NOD {\n  int info;\n  NOD * link;\n};\nce va afi\u0219a urm\u0103toarea func\u021bie, dac\u0103 este apelat\u0103 prin print(HEAD) ? void print(NOD * head) {\n  NOD * iter = head;\n  while (iter != NULL) {\n    cout << iter -> info << \", \";\n    iter = iter -> link;\n  }\n}\n\n", "answers": [" 10, 2, 8, 5, 7, 3\n", "3, 7, 5, 8, 2, 10\n", "2, 8, 5, 7, 3\n", "2, 8, 5, 7"], "correct_answers": [0]}, {"question": " Se consider\u0103 lista \u00eenl\u0103n\u021buit\u0103 cu elemente numere \u00eentregi din Fig.2. Dat\u0103 urm\u0103toarea defini\u021bie a tipului de date ce corespunde unui nod al listei,\n  struct NOD {\n    int info;\n    NOD * link;\n  };\n\nce va afi\u0219a urm\u0103toarea func\u021bie, dac\u0103 este apelat\u0103 prin print(HEAD) ? void print(NOD * head) {\n  NOD * iter = head;\n  while (iter -> link != NULL) {\n    cout << iter -> info << \", \";\n    iter = iter -> link;\n  }\n}\n", "answers": ["10, 2, 8, 5, 7, 3\n", " 10, 2, 8, 5, 7\n", "2, 8, 5, 7, 3, 10\n", "2, 8, 5, 7"], "correct_answers": [1]}, {"question": " Se consider\u0103 lista \u00eenl\u0103n\u021buit\u0103 cu elemente numere \u00eentregi din Fig.2. Dat\u0103 urm\u0103toarea defini\u021bie a tipului de date ce corespunde unui nod al listei,\n  struct NOD {\n    int info;\n    NOD * link;\n  };\nce va afi\u0219a urm\u0103toarea func\u021bie, dac\u0103 este apelat\u0103 prin print(HEAD) ? void print(NOD * head) {\n  NOD * iter = head;\n  while (iter -> link != NULL) {\n    iter = iter -> link;\n    if ((iter -> info) % 2) cout << iter -> info << \", \";\n  }\n}\n", "answers": ["10, 2, 8, 5, 7, 3\n", "10, 3, 7, 5, 8, 2\n", "2, 8, 5, 7, 3\n", " 5, 7, 3"], "correct_answers": [3]}, {"question": " Se d\u0103 urm\u0103toarea func\u021bie\nvoid interclasare(int x[], int prim, int mijloc, int ultim, int C[]) {\n  // lista A: x[prim ..mijloc]\n  // lista B: x[mijloc+1 ..ultim]\n  // lista C: C[0.. ultim - prim]\n  int iterA = prim, iterB = mijloc + 1, iterC = 0;\n  while (iterA <= mijloc && iterB <= ultim)\n    if (x[iterA] < x[iterB])\n      C[iterC++] = x[iterA++];\n    else C[iterC++] = x[iterB++];\n  while (iterA <= mijloc)\n    C[iterC++] = x[iterA++];\n\n  while (iterB <= ultim)\n    C[iterC++] = x[iterB++];\n}\nDac\u0103 vectorul x = (9, 15, 23, 25, 4, 5, 8), care va fi vectorul C la apelarea func\u021biei interclasare(x, 0,\n    3, 6, C) ?\n", "answers": ["  4, 5, 8, 9, 15, 23, 25\n", "0, 0, 0, 0, 0, 0, 0\n", "9, 4, 15, 5, 23, 8, 25\n", "9, 15, 23, 25, 4, 5, 8"], "correct_answers": [0]}, {"question": " Se d\u0103 urm\u0103toarea func\u021bie, care apeleaz\u0103 func\u021bia interclasare descris\u0103 la exerci\u021biul 29. void mergesort(int x[], int prim, int ultim) {\n  if (prim < ultim) {\n    int mijloc = (prim + ultim) / 2;\n    mergesort(x, prim, mijloc);\n    mergesort(x, mijloc + 1, ultim);\n    int C[ultim - prim + 1];\n    interclasare(x, prim, mijloc, ultim, C);\n    for (int i = prim; i <= ultim; i++) x[i] = C[i - prim];\n  }\n}\nLa apelul func\u021biei mergesort(x, 0, 6) unde vectorul x = (9, 15, 23, 2, 4, 5, 8), de c\u00e2te ori va fi apelat\u0103 func\u021bia mergesort(incluz\u00e2nd apelul ini\u021bial) ?\n", "answers": ["1\n", "3\n", " 13\n", "7"], "correct_answers": [2]}, {"question": " Ordinul de complexitate a algoritmului de sortare prin inserare este\n", "answers": ["O(n)\n", " O(n2)\n", "O(n log n)\n", "O(n3)"], "correct_answers": [1]}, {"question": " Ordinul de complexitate a algoritmului de c\u0103utare secven\u021bial\u0103 este\n", "answers": [" O(n)\n", "O(n2)\n", "O(n log n)\n", "O(log n)"], "correct_answers": [0]}, {"question": " O list\u0103 liniar\u0103 \u00een care inser\u0103rile \u0219i \u0219tergerile \u00een lista se fac pe la un singur cap\u0103t se nume\u0219te\n", "answers": [" stiv\u0103\n", "vector\n", "coad\u0103\n", "arbore"], "correct_answers": [0]}, {"question": " Ordinul de complexitate a algoritmului de sortare prin selec\u021bie este\n\n", "answers": ["O(n)\n", " O(n2)\n", "O(n log n)\n", "O(n3)"], "correct_answers": [1]}, {"question": " Se d\u0103 urm\u0103toarea func\u021bie \u00een care front \u0219i rear sunt variabile globale \u0219i reprezint\u0103 pointeri la nodurile unei liste liniare reprezentate simplu \u00eenl\u0103n\u021buit, front la primul nod al listei, iar rear pointer la ultimul nod.\n\nvoid fct(int a) {\n  nod * p = new nod;\n  if (p != NULL) {\n    p -> info = a;\n    p -> link = NULL;\n    if (rear != NULL) rear -> link = p;\n    else front = p;\n    rear = p;\n  } else cout << \"OVERFLOW\" << endl;\n}\n\nCe face aceast\u0103 func\u021bie ?\n", "answers": ["Insereaz\u0103 un nod la \u00eenceputul listei.\n", " Insereaz\u0103 un nod la sf\u00e2r\u0219itul listei.\n", "\u0218terge nodul de la \u00eenceputul listei.\n", "\u0218terge nodul de la sf\u00e2r\u0219itul listei."], "correct_answers": [1]}, {"question": " Cel mai r\u0103u caz pentru algoritmul de sortare prin inserare este cazul \u00een care\n", "answers": ["vectorul este deja sortat\n", " vectorul este cresc\u0103tor \u0219i se dore\u0219te sortarea lui \u00een ordine descresc\u0103toare\n", " vectorul este descresc\u0103tor \u0219i se dore\u0219te sortarea lui \u00een ordine cresc\u0103toare\n", "vectorul con\u021bine \u0219i elemente negative"], "correct_answers": [1, 2]}, {"question": " Cel mai bun caz pentru algoritmul de sortare prin inserare este cazul \u00een care\n", "answers": [" vectorul este deja sortat \u00een ordinea dorit\u0103\n", "vectorul nu este creat aleator\n", "vectorul este descresc\u0103tor \u0219i se dore\u0219te sortarea lui \u00een ordine cresc\u0103toare\n", "vectorul con\u021bine \u0219i elemente negative"], "correct_answers": [0]}, {"question": " Num\u0103rul minim de compara\u021bii \u00eentre elementele unui vector cu n elemente care este sortat cu algoritmul de sortare prin inserare este\n", "answers": ["n\n", "n + 1\n", " n - 1\n", "log n."], "correct_answers": [2]}, {"question": " Num\u0103rul minim de compara\u021bii \u00eentre elementele unui vector cu n elemente care este sortat cu algoritmul de sortare prin metoda bulelor(Bubblesort) este\n", "answers": [" n - 1\n", "n + 1\n", "n\n\n", "n log n."], "correct_answers": [0]}, {"question": " Num\u0103rul maxim de compara\u021bii \u00eentre elementele unui vector cu n elemente care este sortat cu algoritmul de sortare prin metoda bulelor(Bubblesort) este\n", "answers": ["n!\n", "n(n + 1) / 2\n", " n(n - 1) / 2\n", "n log n."], "correct_answers": [2]}, {"question": " C\u00e2te compara\u021bii se fac dac\u0103 se folose\u0219te algoritmul de c\u0103utare secven\u021bial\u0103 pentru c\u0103utarea elementului 9 \u00een vectorul(8, 3, 5, 9, 11, 2) ?\n", "answers": ["6\n", "5\n", "3\n", "4"], "correct_answers": []}, {"question": " C\u00e2te compara\u021bii se fac dac\u0103 se folose\u0219te algoritmul de c\u0103utare binar\u0103 pentru c\u0103utarea elementului19 \u00een vectorul(1, 2, 3, 5, 8, 9, 19) ?\n", "answers": ["6\n", "5\n", " 3\n", "O(log 7)"], "correct_answers": [2]}, {"question": " Dac\u0103 se aplic\u0103m metoda bulelor(bubblesort) pentru sortarea vectorului x = (9, 15, 23, 25, 4, 8, 5), cum se va modifica vectorul x dup\u0103 prima parcurgere a sa ?\n", "answers": ["4, 5, 8, 9, 15, 23, 25\n", " 9, 15, 23, 4, 8, 5, 25\n", "9, 4, 15, 5, 23, 8, 25\n", "9, 15, 23, 25, 4, 5, 8"], "correct_answers": [1]}, {"question": " Dac\u0103 se aplic\u0103m metoda bulelor(bubblesort) pentru sortarea vectorului x = (9, 15, 23, 25, 4, 8, 5), cum se va modifica vectorul x dup\u0103 dou\u0103 parcurgeri ale sale ?\n", "answers": ["4, 5, 8, 9, 15, 23, 25\n", " 9, 15, 4, 8, 5, 23, 25\n", "9, 4, 15, 5, 23, 8, 25\n", "9, 15, 23, 25, 4, 5, 8"], "correct_answers": [1]}, {"question": " Dac\u0103 se aplic\u0103m sortarea prin inserare pentru sortarea vectorului x = (9, 15, 23, 25, 4, 8, 5), care este primul element al vectorului a c\u0103rui analiz\u0103 va implica efectuarea de modific\u0103ri asupra vectorului ?\n", "answers": ["15\n", "23\n", "25\n", " 4"], "correct_answers": [3]}, {"question": " Care din urm\u0103toarele afirma\u021bii sunt adev\u0103rate ?\n", "answers": ["La aplicarea algoritmului de sortare rapid\u0103 elementul din mijloc este mutat pe prima pozi\u021bie.\n", "La aplicarea algoritmului de sortare rapid\u0103 elementul de pe prima pozi\u021bie este mutat pe pozi\u021bia din mijloc.\n", " La aplicarea algoritmului de sortare rapid\u0103 se alege un element din list\u0103, numit pivot \u0219i se rearanjeaz\u0103 lista, prin interschimb\u0103ri, inclusiv prin mutarea pivotului pe o alt\u0103 pozi\u021bie, astfel \u00eenc\u00e2t toate elementele mai mici dec\u00e2t pivotul s\u0103 fie pozi\u021bionate inaintea lui, iar toate elementele mai mari s\u0103 fie pozi\u021bionate dup\u0103 acesta.\n\n", "La aplicarea algoritmului de sortare rapid\u0103 nu se alege niciun element pivot."], "correct_answers": [2]}, {"question": " Care din urm\u0103toarele afirma\u021bii sunt adev\u0103rate ?\n", "answers": ["  Arborele din figura Fig.1 este un arbore binar.\n", "Arborele din figura Fig.1 nu este un arbore binar.\n", " Arborele din figura Fig.1 este un arbore binar de c\u0103utare.\n", "Arborele din figura Fig.1 nu este un arbore binar de c\u0103utare."], "correct_answers": [0, 2]}, {"question": " Parcurgerea in preordine a arborelui din Fig.2 va afi\u0219a\n\nFig.2\n", "answers": [" / , +, 50, *, 25, 3, 8, -, 3\n", " / , 50, +, *, 3, 25, 8, -, 3\n", "50, +, 25, *, 3, 8, -, 3, /\n", " /, +, 50, *, 25, 3, -, 8, 3"], "correct_answers": [3]}, {"question": " Parcurgerea in inordine a arborelui din Fig.2 va afi\u0219a\n", "answers": [" / , +, 50, *, 25, 3, 8, -, 3\n", " 50, +, 25, *, 3, /, 8, -, 3\n", "50, +, 25, *, 3, 8, -, 3, /\n", "50, /, +, *, 25, 3, -, 8, 3"], "correct_answers": [1]}, {"question": " Parcurgerea in postordine a arborelui din Fig.2 va afi\u0219a\n", "answers": [" 50, 25, 3, *, +, 8, 3, -, /\n", " / , 50, +, *, 3, 25, 8, -, 3\n", "50, +, 25, *, 3, 8, -, 3, /\n", " / , +, 50, *, 25, 3, -, 8, 3"], "correct_answers": [0]}]