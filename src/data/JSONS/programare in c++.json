[{"question": " Fie secven\u021ba:\n\n  class cls {\n    public: cls() {\n      cout << \"constructor\";\n    }\n    cls(cls & c) {\n      cout << \"constructor de copiere\";\n    }\n  };\nint f(cls c) {\n  return 1;\n}\nint main() {\n  cls c;\n  f(c);\n  return 0;\n}\n\n\u00cen momentul execut\u0103rii programului de mai sus:\n\n", "answers": [" constructorul de clas\u0103 se apeleaz\u0103 o dat\u0103, iar cel de copiere nu se apeleaz\u0103;\n", " constructorul de clas\u0103 \u015fi cel de copiere se apeleaz\u0103 fiecare c\u00e2te o dat\u0103;\n", " constructorul de copiere se apeleaz\u0103 o dat\u0103, iar cel de clas\u0103 nu se apeleaz\u0103;\n", " constructorul de clas\u0103 se apeleaz\u0103 de dou\u0103 ori, iar cel de copiere nicio dat\u0103;\n", " constructorul de clas\u0103 \u0219i cel de copiere se apeleaz\u0103 fiecare de c\u00e2te dou\u0103 ori.\n"], "correct_answers": [1]}, {"question": " Fie secven\u021ba:\n\n  class cls {\n    public: cls() {\n      cout << \"constructor\";\n    }\n    cls(cls & c) {\n      cout << \"constructor de copiere\";\n    }\n  };\nint f(cls & c) {\n  return 1;\n}\nint main() {\n  cls c;\n  f(c);\n  return 0;\n}\n\n\u00cen momentul execut\u0103rii programului de mai sus:\n\n", "answers": [" constructorul clasei se apeleaz\u0103 o dat\u0103, iar cel de copiere nu se apeleaz\u0103 nicio dat\u0103;\n", " constructorul de clas\u0103 \u015fi cel de copiere se apeleaz\u0103 fiecare c\u00e2te o dat\u0103;\n", " constructorul de copiere se apeleaz\u0103 o dat\u0103, iar cel de clas\u0103 nu se apeleaz\u0103;\n", " constructorul clasei se apeleaz\u0103 de dou\u0103 ori, iar cel de copiere nicio dat\u0103;\n", " constructorul de clas\u0103 \u0219i cel de copiere se apeleaz\u0103 fiecare de c\u00e2te dou\u0103 ori.\n"], "correct_answers": [0]}, {"question": " Fie secven\u021ba:\n\n  class C {\n    int a;\n    public:\n      virtual void metoda1() = 0;\n    virtual void metoda2() = 0;\n  };\n\nint main() {\n  C * pob; //declara\u021bia\t1\n  C ob; //declara\u021bia\t2\n  C * vpob[5]; //declara\u021bia\t3\n  C vob[5]; //declara\u021bia\t4\n  return 0;\n}\n\nDeclara\u021biile admise \u00een acest caz sunt:\n\n", "answers": [" Declara\u021biile 1 \u0219i 2;\n", " Declara\u021bia 1;\n", " Declara\u021biile 2 \u0219i 4;\n", " Declara\u021bia 3;\n", " Declara\u021biile 1, 2 \u0219i 3.\n"], "correct_answers": [1, 3]}, {"question": " Fie clasa:\n\n  class c {\n    int a, b;\n    public:\n      c(int, int);\n    int det_a() {\n        return a;\n      }\n      ~c();\n  };\n\nSemnul~are rolul:\n\n", "answers": [" de a nega pe bi\u021bi rezultatul returnat de metoda c();\n", " de a preciza existen\u021ba destructorului;\n", " de a nega logic rezultatul returnat de metoda c();\n", " de a supra\u00eencarca constructorul clasei;\n", " de a supra\u00eencarca operatorul~\n"], "correct_answers": [1]}, {"question": " Secven\u0163a urm\u0103toare:\n\n  class c1 {\n    public: int a;\n    c1(int y) {\n      a = y;\n      cout << \"constructor 1\";\n    }\n    ~c1() {\n      cout << \"destructor 2\";\n    }\n  };\nclass c2: public c1 {\n  public: int b;\n  c2(int y, int x): c1(y) {\n      b = x;\n      cout << \"constructor 2\";\n    }\n    ~c2() {\n      cout << \"destructor 2\";\n    }\n};\nint main() {\n  c1 ob1(2);\n  c2 ob2(2, 3);\n  return 0;\n\n}\n\nafi\u0219eaz\u0103:\n\n", "answers": [" constructor 1 constructor 2 destructor 2 destructor 1\n", " constructor 1 constructor 1 constructor 2 destructor 2 destructor 1 destructor 1\n", " constructor 1 constructor 2 constructor 1 destructor 1 destructor 2 destructor 1\n", " constructor 1 constructor 1 constructor 2 destructor 2 destructor 1\n"], "correct_answers": [1]}, {"question": " Fie urm\u0103torul program C++:\n\n#include <iostream.h> class B{\n\npublic:\n  B() {\n    cout << \"B()\" << endl;\n  }\n  ~B() {\n    cout << \"~B()\" << endl;\n  }\n};\n\nclass D: public B {\n  public: D() {\n      cout << \"D()\" << endl;\n    }\n    ~D() {\n      cout << \"~D()\" << endl;\n    }\n};\nint main() {\n  B * b = new B();\n  delete b;\n  b = new D();\n  delete b;\n  return 0;\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" B() ~B() B() D() ~D()\n", " B() ~B() B() D() ~B()\n", " B() ~B() B() ~B()\n", " B() ~B() D() ~B()\n"], "correct_answers": [1]}, {"question": " Fie programul:\n\n  #include <iostream.h> class B{\n\n  public:\n  B() {\n    cout << \"B()\" << endl;\n  }\nB(B & b) {\n  cout << \"B(B &b)\" << endl;\n}\n};\nclass D: public B {\n  public: D() {\n    cout << \"D()\" << endl;\n  }\n  D(D & d) {\n    cout << \"D(D &d)\" << endl;\n  }\n};\nint main() {\n  B b;\n  B b1(b);\n  D d;\n  D d1(d);\n  return 0;\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" B() B(B & b) B() D() B(B & b) D(D & d)\n", " B() B() B(B & b) B() D() B(B & b) D() B(B & b)\n", " B() B(B & b) D() B(B & b) D() B(B & b)\n", " B() B(B & b) B() D() B() D(D & d)\n"], "correct_answers": [3]}, {"question": " Fie clasa:\n  class c {\n    int a, b;\n    public:\n      float c(int, int) int get_a {\n        return a;\n      }\n    c();\n  };\n\nDeclara\u0163ia float c(int, int) ar putea corespunde unui constructor al clasei ?\n\n", "answers": [" da, fiind o supra\u00eencarcare a celui existent;\n", " nu, deoarece creaz\u0103 ambiguitate;\n", " nu, deoarece constructorul nu are tip returnat;\n", " nu, deoarece nu este de tip friend.\n"], "correct_answers": [2]}, {"question": " Fie secven\u0163a urm\u0103toare:\n\n  class persoana {\n    int varsta;\n    public:\n      persoana(int v = 18) {\n        varsta = v;\n      }\n    persoana & operator++(int) {\n      varsta++;\n      return * this;\n    }\n    int get_varsta() {\n      return varsta;\n    }\n  };\nint main() {\n  persoana p(20);\n  cout << p++.get_varsta();\n  return 0;\n}\n\nSecven\u021ba afi\u0219eaz\u0103:\n\n", "answers": [" 21\n", " 20\n", " 18\n", " 19\n"], "correct_answers": [0]}, {"question": " O func\u021bie declarat\u0103 friend \u00een clasa de baz\u0103:\n\n", "answers": [" r\u0103m\u00e2ne friend \u00een clasa derivat\u0103, pentru partea mo\u0219tenit\u0103;\n", " are acces pe toat\u0103 clasa derivat\u0103;\n", " nu are acces pe zonele private \u0219i protected ale clasei derivate;\n", " nu are acces pe zona private a clasei derivate;\n", " are acces pe zonele public \u0219i protected ale clasei derivate.\n"], "correct_answers": [2, 3]}, {"question": " Se consider\u0103 urm\u0103toarea secven\u021b\u0103 de program:\n\n  class B {\n    private: int x,\n    y;public: B(int a, int b) {\n      x = a;\n      y = b;\n    }\n    B(const B & a) {\n      x = a.x;\n      y = a.y;\n    }\n  };\n\n\u00cen care dintre urm\u0103toarele situa\u021bii se realizeaz\u0103 copierea unui obiect \u00eentr - altul:\n\n", "answers": [" B c1(4, 5);\n", " B c2(0.0, 0, 0);\n", " B c1, c3 = c1;\n", " B c4(1);\n", " B c1, c5(c1).\n"], "correct_answers": [2, 4]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class cls {\n\n  static int i;\nint j;\npublic:\n  cls(int x = 7) {\n    j = x;\n  }\nstatic int imp(int k) {\n  cls a;\n  return i + k + a.j;\n}\n};\nint cls::i;\nint main() {\n  int k = 5;\n  cout << cls::imp(k);\n  return 0;\n}\nIndica\u021bi ce se va afi\u0219a pe ecran \u00een urma execut\u0103rii programului:\n\n", "answers": [" 11\n", " 13\n", " 12\n", " 14"], "correct_answers": [2]}, {"question": " Fie urm\u0103torul program:\n\n  #include <iostream.h> class B{\n\n  public:\n  virtual void f() {\n    cout << \"B::f() \";\n  }\nvoid g() {\n  cout << \"B::g() \";\n}\n};\n\nclass D: public B {\n  public: void f() {\n    cout << \"D::f() \";\n  }\n  void g() {\n    cout << \"D::g() \";\n  }\n};\nint main() {\n  int i;\n  B * a = new B();\n  B * b = new D();\n  a -> f();\n  b -> f();\n  a -> g();\n  b -> g();\n  return 0;\n}\n\nIndica\u021bi ce se va afi\u0219a pe ecran \u00een urma execut\u0103rii programului:\n", "answers": [" D::f() B::f() B::g() B::g() B::g()\n", " B::f() D::f() B::g() B::g()\n", " B::f() D::f() B::g() D::g()\n", " B::f() B::g() D::f() D::g()\n"], "correct_answers": [1]}, {"question": " Fie urm\u0103torul program:\n\n  #include <iostream.h> class B{\n\n  public:\n  virtual void f() {\n    cout << \"B::f() \";\n  }\nvoid g() {\n  cout << \"B::g() \";\n}\n};\n\nclass D1: public B {\n  public: void f() {\n    cout << \"D1::f() \";\n  }\n  void g() {\n    cout << \"D1::g() \";\n  }\n};\nclass D2: public B {\n  public: void g() {\n    cout << \"D2::g() \";\n  }\n};\nint main() {\n  int i;\n  B * a = new B();\n  B * b = new D1();\n  B * c = new D2();\n  a -> f();\n  b -> f();\n  c -> f();\n  a -> g();\n  b -> g();\n  c -> g();\n  return 0;\n}\n\nIndica\u021bi ce se va afi\u0219a pe ecran \u00een urma execut\u0103rii programului:\n", "answers": [" B::f() D1::f() B::f() B::g() B::g() B::g()\n", " D2::f() D1::f() B::f() B::g() B::g() B::g()\n", " B::f() D1::f() D::f() B::g() D1::g() D2::g()\n", " B::f() D1::f() B::f() B::g() D1::g() D2::g()\n", " B::f() B::f() D2::f() B::g() B::g() D2::g()\n"], "correct_answers": [0]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class salariat{\n\n  int varsta;\npublic:\n  salariat(int v = 20) {\n    varsta = v;\n  }\noperator int() {\n  return varsta;\n}\nsalariat & operator++() {\n  varsta++;\n  return * this;\n}\nsalariat operator++(int) {\n  varsta++;\n  return * this;\n}\n};\nint main() {\n  salariat s(21);\n  int a = s++, b = ++s;\n  cout << a << \"\t\" << b << endl;\n  return 0;\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" 20 21\n", " 21 22\n", " 22 23\n", " 20 22\n", " 21 23\n"], "correct_answers": [2]}, {"question": " Fie urm\u0103torul program:\n\n  #include <iostream.h> class Cerc{\n\n  public:\n  float raza;\nCerc(float r) {\n  raza = r;\n}\nfloat get_raza() {\n  return raza;\n}\nCerc operator++() {\n  raza++;\n  return * this;\n}\nCerc operator--() {\n  raza--;\n  return * this;\n}\n};\nint main() {\n  Cerc c(3.5);\n  cout << (++(++c)).get_raza() << \" \";\n  cout << c.get_raza() << \" \";\n  cout << (--(--c)).get_raza() << \" \";\n  cout << c.get_raza() << \" \";\n  return 0;\n\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" 3.5 4.5 2.5 3.5\n", " 5.5 4.5 2.5 2.5\n", " 2.5 5.5 4.5 3.5\n", " 5.5 4.5 2.5 3.5\n", " 4.5 2.5 3.5 5.5\n"], "correct_answers": []}, {"question": " O metod\u0103 static\u0103 a unui obiect se caracterizeaz\u0103 prin faptul c\u0103:\n\n", "answers": [" nu prime\u0219te pointerul la obiect this;\n", " folose\u0219te numai datele publice;\n", " se poate apela prin numele clasei;\n", " nu poate fi definita dec\u00e2t inline;\n", " daca prelucreaz\u0103 obiecte, prime\u0219te obiectele ca parametrii explici\u021bi.\n"], "correct_answers": [0, 2, 4]}, {"question": " Fie secven\u021ba de program:\n\n  #include <iostream.h> class C{\n\n  public:\n  static int s;\n};\nint C::s = 0;\nint main() {\n  int a = 7;\n  C::s = a;\n  cout << C::s;\n  return 0;\n}\n\n\u00cen secven\u021ba de mai sus, ini\u021bializarea lui s este:\n\n", "answers": [" ilegal\u0103, deoarece nu exist\u0103 niciun obiect creat;\n", " ilegal\u0103, deoarece s este ini\u021bializat \u00een afara clasei;\n", " ilegal\u0103, deoarece s este dublu definit, \u00een clas\u0103 \u0219i \u00een afara ei;\n", " ilegal\u0103, deoarece datele statice pot fi doar private;\n", " corect\u0103, deoarece membri statici exist\u0103 \u00eenainte de a se crea obiecte din clas\u0103.\n"], "correct_answers": [4]}, {"question": " Fie secven\u021ba:\n\n  class complex {\n    double re;\n    double im;\n    public:\n      complex(double x = 1.0, double y = 6.80) {\n        re = x;\n        im = y;\n      }\n    complex(const complex & u) {\n      re = u.re;\n      im = u.im;\n    }\n  };\n\nPreciza\u0163i \u00een ce situa\u0163ie se utilizeaz\u0103 constructorul de copiere:\n\n", "answers": [" complex z1(5.2, 3.6);\n", " complex z1(5.2, 3.6), z2 = z1;\n", " complex z3(0.1, 1.0);\n", " complex z1(5.2, 3.6), z4(z1);\n", " complex z5(-0.1, 28.7).\n"], "correct_answers": [1, 3]}, {"question": " Fie secven\u021ba:\n\n  class A1 {\n    public: A1() {\n      cout << \"A1 \";\n    }\n  };\nclass A2 {\n  public: A2() {\n    cout << \"A2 \";\n  }\n};\nclass AA1: public A1, virtual public A2 {\n  public: AA1() {\n    cout << \"AA1 \";\n  }\n};\nclass AA2: public A1, virtual A2 {\n  public: AA2() {\n    cout << \"AA2 \";\n  }\n};\nclass B: public AA1, virtual public AA2 {\n  public: B() {\n    cout << \"B \";\n  }\n};\nint main() {\n  B ob1;\n  return 0;\n}\n\nSecven\u021ba afi\u0219eaz\u0103:\n\n", "answers": [" A1 A2 AA2 A1 AA1 B\n", " A2 A2 AA2 AA1 A1 B\n", " A1 A2 AA2 A1 B AA1\n", " A2 A1 AA2 A1 AA1 B\n", " A2 A1 A2 AA1 A1 B\n"], "correct_answers": [3]}, {"question": " Care dintre afirma\u021biile urm\u0103toare sunt adev\u0103rate ?\n\n", "answers": [" preceden\u021ba unui operator poate fi modificat\u0103 prin redefinire;\n", " aritatea unui operator nu poate fi modificat\u0103 prin redefinire;\n", " asociativitatea unui operator poate fi modificat\u0103 prin redefinire;\n", " semnifica\u021bia modului \u00een care lucreaz\u0103 un operator asupra obiectelor de tipuri predefinite nu poate fi schimbat\u0103 prin redefinire.\n"], "correct_answers": [1, 3]}, {"question": " Care dintre afirma\u021biile urm\u0103toare sunt adev\u0103rate ?\n\n", "answers": [" func\u021biile inline nu pot fi func\u021bii virtuale;\n", " constructorii pot fi func\u021bii virtuale;\n", " orice func\u021bie membru static\u0103 este func\u021bie virtual\u0103;\n", " destructorul poate fi func\u021bie virtual\u0103.\n"], "correct_answers": [0, 3]}, {"question": " Fie programul:\n\n  #include <iostream.h> class Cerc{\n\n  float raza;\npublic:\n  Cerc(float r) {\n    raza = r;\n  }\nfloat get_raza() {\n  return raza;\n}\nvoid operator++() {\n  raza++;\n}\n};\nclass Cilindru: public Cerc {\n  float inaltime;\n  public:\n    Cilindru(float raza, float i): Cerc(raza) {\n      inaltime = i;\n    }\n  void operator++() {\n    inaltime++;\n  }\n  float get_inaltime() {\n    return inaltime;\n  }\n};\nint main() {\n  Cerc * pc;\n  Cilindru c(2, 6);\n  pc = & c;\n  ++ * pc;\n  cout << pc -> get_raza() << \" \" << c.get_inaltime() << endl;\n  return 0;\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" 2 5\n", " 2 6\n", " 3 6\n", " 2 5\n"], "correct_answers": [2]}, {"question": " Care dintre afirma\u021biile urm\u0103toare sunt false ?\n\n", "answers": [" obiectele unei clase derivate au acces la membrii priva\u021bi ai clasei sale de baz\u0103;\n", " rela\u021bia de mo\u0219tenire este tranzitiv\u0103;\n", " func\u021biile friend ale clasei de baz\u0103 se mo\u0219tenesc de c\u0103tre clasa derivat\u0103;\n", " constructorul \u0219i destructorul clasei de baz\u0103 se mo\u0219tenesc \u00een clasa derivat\u0103.\n"], "correct_answers": [0, 2, 3]}, {"question": " Fie urm\u0103torul program:\n\n  #include<ostream.h> class persoana{\n\n  int varsta, salariul;\nfriend ostream & operator << (ostream & out, persoana p) {\n  out << p.varsta << \" \" << p.salariul;\n  return out;\n}\npublic:\n  persoana(int v) {\n    varsta = v;\n    salariul = 0;\n  }\npersoana() {\n  varsta = 0;\n  salariul = 0;\n}\n};\nint main() {\n  persoana p(1);\n  cout << p;\n  return 0;\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" 1 0\n", " 0 0\n", " 1 1\n", " 0 1\n"], "correct_answers": [0]}, {"question": " Supra\u00eenc\u0103rcarea unor operatori se poate realiza prin func\u0163ii operator sau prin func\u0163ii friend.Diferen\u021ba dintre aceste dou\u0103 posibilit\u0103\u021bi const\u0103 \u00een:\n\n", "answers": [" lista de parametri;\n", " obiectul returnat;\n", " preceden\u021ba operatorilor;\n", " aritatea operatorului.\n"], "correct_answers": [0, 2]}, {"question": " Fie programul:\n  class c {\n    int a;\n    public:\n      c() {};\n    c(const c & ) {};\n    void operator = (c & ) {};\n  };\nint main() {\n  c a;\n  c b = a;\n}\n\nLinia de cod c b = a;\ndetermin\u0103:\n\n", "answers": [" executarea constructorului de copiere;\n", " executarea metodei prin care se supra\u00eenc\u0103rc\u0103 operatorul = ;\n", " executarea at\u00e2t a constructorului de copiere, c\u00e2t \u0219i a metodei operator = ;\n", " o eroare, deoarece nu este permis\u0103 combinarea atribuirii cu o declara\u021bie;\n", " executarea constructorului implicit.\n"], "correct_answers": [0]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class cls{\n\n  public:\n  ~cls() {\n    cout << \"\\n Destructor\";\n  }\n};\nint main() {\n  cls * po = new cls[3];\n  delete[] po;\n}\n\nDestructorul clasei:\n\n", "answers": [" nu se apeleaz\u0103 nicio dat\u0103;\n", " se apeleaz\u0103 o dat\u0103;\n", " se apeleaz\u0103 de trei ori;\n", " se apeleaz\u0103 de patru ori.\n"], "correct_answers": [2]}, {"question": " O func\u021bie independent\u0103 declarat\u0103 friend \u00een domeniul public dintr - o clas\u0103 \u0219i care prime\u0219te ca parametru o referin\u021b\u0103 la un obiect al clasei respective are acces:\n\n", "answers": [" doar la membrii declara\u021bi public;\n", " la to\u021bi membrii;\n", " la membrii public \u0219i la cei protected;\n", " la membrii protected.\n"], "correct_answers": [1]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class A{\n\n  int a[3];\npublic:\n  A(int i, int j, int k) {\n    a[0] = i;\n    a[1] = j;\n    a[2] = k;\n  }\nint & operator[](int i) {\n  return a[i];\n}\n};\nint main() {\n  A ob(1, 2, 3);\n  cout << ob[1];\n  ob[1] = 25;\n  cout << ob[1];\n  return 0;\n}\n\nCe se poate afirma despre operator[]() ?\n\n", "answers": [" produce supra\u00eenc\u0103rcarea unei func\u0163ii;\n", " produce supra\u00eenc\u0103rcarea unui operator unar;\n", " supra\u00eencarc\u0103 operatorul[];\n", " este o func\u0163ie membru oarecare a clasei A, care nu produce supra\u00eenc\u0103rcarea unui operator;\n", " reprezint\u0103 un operator ternar.\n"], "correct_answers": []}, {"question": " Consider\u0103m urm\u0103torul program:\n\n  #include<iostream.h> class C{\n\n  public:\n  int x;\nC(int v) {\n  x = v;\n}\ndouble operator + (C & c, double d) {\n  return c.x + d;\n}\ndouble operator + (double d, C & c) {\n  return c.x + d;\n}\n};\nint main() {\n  C c(5);\n  cout << 2 + c + 3;\n  return 0;\n}\n\nStabili\u021bi care dintre urm\u0103toarele afirma\u021bii sunt adev\u0103rate:\n\n", "answers": [" supra\u00eenc\u0103rc\u0103rile operator + () trebuie s\u0103 fie friend;\n", " supra\u00eenc\u0103rc\u0103rile operator + () nu se justific\u0103 deoarece au acela\u0219i cod;\n", " programul afi\u0219eaz\u0103 10;\n", " supra\u00eenc\u0103rc\u0103rile operator + () trebuie s\u0103 returneze referin\u021be.\n"], "correct_answers": [0]}, {"question": " Fie programul:\n\n  #include<iostream.h> class c1{ int a;}; class c2:public c1{\n\n  public:\n  int b;\nvoid scrie_a() {\n  cout << a;\n}\n};\nint main() {\n  c2 ob;\n  ob.scrie_a();\n  return 0;\n}\n\nSelecta\u0163i afirma\u0163ia corect\u0103:\n\n", "answers": [" func\u021bia scrie_a() nu are acces asupra unui membru privat;\n", " programul afi\u0219eaz\u0103 valoarea lui a;\n", " derivarea public\u0103 este incorect realizat\u0103;\n", " prin derivare public\u0103, accesul la membrii mo\u015fteni\u0163i devine public.\n"], "correct_answers": [0]}, {"question": " Fie programul urm\u0103tor:\n\n  #include<iostream.h> class B{\n\n  int x;\npublic:\n  B(int i = 10) {\n    x = i;\n  }\nint get_x() {\n  return x;\n}\n};\nclass D: public B {\n  public: D(int i): B(i) {}\n  D operator + (const D & a) {\n    return x + a.x;\n  }\n};\nint main() {\n  D ob1(7), ob2(-12);\n  cout << (ob1 + ob2).get_x();\n  return 0;\n}\n\nProgramul afi\u0219eaz\u0103:\n\n", "answers": [" eroare, clasa B nu poate fi mo\u0219tenit\u0103 de clasa D;\n", " eroare, metoda operator nu are acces la un membru privat al clasei de baz\u0103;\n", " programul afi\u0219eaz\u0103 valoarea - 5;\n", " eroare, operatorul + nu se poate aplica pentru tipuri abstracte de date.\n"], "correct_answers": [1]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class B1{int x;}; class B2{int y;}; class B3{int z;}; class B4{int t;};\n\n  class D: public B1, private B2, protected B3, B4 {\n    public: int m;\n  };\nint main() {\n  D d;\n  cout << d.m; //varianta 1\n  cout << d.x; //varianta 2\n  cout << d.y; //varianta 3\n  return 0;\n}\n\nVariantele care permit accesul la variabile pentru afi\u0219are sunt:\n\n", "answers": [" 1 + 3;\n", " 1 + 2;\n", " 1 + 2 + 3;\n", " 1\n"], "correct_answers": [3]}, {"question": " Consider\u0103m urm\u0103torul program:\n\n  class vector {\n    int * pe, nr_c;\n    public:\n      operator int() {\n        return nr_c;\n      }\n    vector(int);\n  };\nvector::vector(int n) {\n  pe = new int[n];\n  nr_c = n;\n  while (n--) pe[n] = n;\n}\nvoid f(int i) {\n  cout << i << endl;\n}\nint main() {\n  vector x(10);\n  f(x);\n  return 0;\n}\n\nProgramul afi\u015feaz\u0103:\n\n", "answers": [" 9\n", " 10\n", " numerele de la 1 la 10\n", " numerele de la 0 la 9\n"], "correct_answers": [1]}, {"question": " Consider\u0103m urm\u0103torul program:\n\n  class c {\n    int a;\n    public:\n      virtual void metoda1() = 0;\n    virtual void metoda2(int) = 0;\n  };\nint main {\n  c * pob; //declara\u0163ia 1\n  c ob; //declara\u0163ia 2 c *vpob[3];  //declara\u0163ia 3 c vob[3]; //declara\u0163ia 4 return 0;\n}\n\nDeclara\u0163iile admise:\n\n", "answers": [" 1 + 2;\n", " 1 + 2 + 3 + 4\n", " nici una\n", " 1 + 3;\n"], "correct_answers": [3]}, {"question": " Fie data urmatoarea ierarhie:\n\n  class B {\n    \u2026}\nclass D1: B {\n  \u2026}\nclass D2: B {\n  \u2026}\nclass M1: D1, public D2 {\n  \u2026}\nclass M2: virtual D1, virtual D2 {\n  \u2026}\n\nConsider\u0103m urm\u0103toarele afirma\u0163ii:\n", "answers": [" clasa M1 va mo\u015fteni un obiect de tip B;\n", " clasa M1 va mo\u015fteni dou\u0103 obiecte de tip B;\n", " clasa M2 va va mo\u015fteni un obiect de tip B;\n", " clasa M2 va mo\u015fteni dou\u0103 obiecte de tip B.\n\nPreciza\u0163i care dintre afirma\u0163iile de mai sus sunt corecte:\n\n", " 2 + 3\n", " 1 + 2\n", " 1 + 3\n", " 2 + 4\n"], "correct_answers": [4]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class B{\n\n  public:\n  int x;\nB(int i = 16) {\n  x = i;\n}\nB f(B ob) {\n  return x + ob.x;\n}\n};\nclass D: public B {\n  public: D(int i = 25) {\n    x = i;\n  }\n  B f(B ob) {\n    return x + ob.x + 1;\n  }\n  void afisare() {\n    cout << x;\n  }\n};\nint main() {\n  B * p1 = new D, * p2 = new B, * p3 = new B(p1 -> f( * p2));\n  cout << p3 -> x;\n  return 0;\n}\n\nProgramul afi\u015feaz\u0103:\n\n", "answers": [" 41\n", " eroare, nu se poate instan\u0163ia un obiect al unei clase derivate printr - un pointer la un obiect de tip clasa de baz\u0103;\n", " 44\n", " 45\n"], "correct_answers": [0]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class B{\n\n  int i;\npublic:\n  static int x;\nB() {\n    x++;\n    i = 1;\n  }\n  ~B() {\n    x--;\n  }\nstatic int get_x() {\n  return x;\n}\nint get_i() {\n  return i;\n}\n};\nint B::x;\nclass D: public B {\n  public: D() {\n      x++;\n    }\n    ~D() {\n      x--;\n    }\n};\nint f(B * q) {\n  return (q -> get_i()) + 1;\n}\nint main() {\n  B * p = new B;\n  cout << f(p);\n  delete p;\n  p = new D;\n  cout << f(p);\n  delete p;\n  cout << D::get_x();\n  return 0;\n}\n\nProgramul afi\u015feaz\u0103:\n", "answers": [" eroare, data membr\u0103 static\u0103 x nu este ini\u0163ializat\u0103;\n", " eroare, metoda get_x() nu poate fi declarat\u0103 static;\n", " programul afi\u015feaz\u0103 valoarea 221;\n", " programul afi\u015feaz\u0103 valoarea 220.\n"], "correct_answers": [2]}, {"question": " Fie urm\u0103torul program:\n\n  #include <iostream.h> template<class T, class E> float f(T x, E y){ return x+y;}\n\n  float g(int x, float y) {\n    return x - y;\n  }\nint main() {\n  int a = 5;\n  float b = 8.6;\n  cout << g(a, b);\n  return 0;\n}\n\nProgramul afi\u015feaz\u0103:\n", "answers": [" 3\n", " eroare, parametrizarea clasei T este incorrect realizat\u0103\n", " 13.6\n", " -3.6"], "correct_answers": [3]}, {"question": " Fie urm\u0103torul program:\n\n  #include <iostream.h> template<class T>\n\n  int f(T x, T y) {\n    return x + y;\n  }\nint f(int x, int y) {\n  return x - y;\n}\nint main() {\n  int a = 5;\n  float b = 8.6;\n  cout << f(a, b);\n  return 0;\n}\n\nProgramul afi\u015feaz\u0103:\n", "answers": [" -3\n", " eroare, parametrizarea clasei T este incorrect realizat\u0103\n", " 13.6\n", " 3.6\n"], "correct_answers": [0]}, {"question": " Fie urm\u0103torul program: #include<iostream.h> class B{\n\n  int x;\n\nB(int i = 10) {\n  x = i;\n}\nint get_x() {\n  return x;\n}\n};\nclass D: public B {\n  public: D(int i): B(i) {}\n  D operator + (const D & a) {\n    return x + a.x;\n  }\n};\nint main() {\n  D ob1(7), ob2(-12);\n  cout << (ob1 + ob2).get_x();\n  return 0;\n}\nIndica\u021bi ce se va afi\u0219a pe ecran \u00een urma execut\u0103rii programului:\n", "answers": [" - 5\n", " - 4\n", " eroare, \u00een clasa derivat\u0103 D nu se poate accesa data membr\u0103 privat\u0103 x a clasei B\n", " - 3"], "correct_answers": [2]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class B{\n\n  public:\n  int x;\nB(int i = 16) {\n  x = i;\n}\nB f(B ob) {\n  return x + ob.x;\n}\n};\nclass D: public B {\n  public: D(int i = 25) {\n    x = i;\n  }\n  B f(B ob) {\n    return x + ob.x + 1;\n  }\n  void afisare() {\n    cout << x;\n  }\n};\nint main() {\n  B * p1 = new D, * p2 = new B, * p3 = new B(p1 -> f( * p2));\n  cout << p3 -> x;\n  return 0;\n}\nProgramul afi\u015feaz\u0103:\n\n", "answers": [" 41\n", " eroare, \u00een clasa derivat\u0103 D nu se poate accesa data membr\u0103 x a clasei B\n", " 16\n", " 25\n"], "correct_answers": [0]}, {"question": " Fie urm\u0103torul program:\n\n  #include<iostream.h> class cls1{\n\n  public:\n  int a;\ncls1() {\n  a = 7;\n}\n};\nclass cls2 {\n  int b;\n  cls2(int i) {\n    b = i;\n  }\n  cls2(cls1 & x) {\n    b = x.a;\n  }\n};\nint main() {\n  cls1 x;\n  cout << x.a;\n  cls2 y(x);\n  cout << y.b;\n  return 0;\n}\n\nProgramul afi\u015feaz\u0103:\n\n", "answers": [" 7 7\n", " eroare, constructorul de copiere nu este corect definit\n", " eroare, constructorul de copiere nu poate accesa o dat\u0103 public\u0103 a clasei cls1\n", " 78\n"], "correct_answers": [0]}, {"question": " O func\u0163ie friend difer\u0103 de o metod\u0103 obi\u015fnuit\u0103 a unei clase prin faptul c\u0103:\n\n", "answers": [" nu se poate defini inline;\n", " nu prime\u015fte pointerul implicit la obiect this;\n", " nu poate accesa dec\u00e2t partea public\u0103 a obiectului;\n", " se folose\u015fte doar pentru supra\u00eenc\u0103rcarea operatorilor;\n", " nu poate returna valori.\n"], "correct_answers": [1]}, {"question": " O func\u0163ie independent\u0103 declarat\u0103 friend \u00een domeniul private dintr - o clas\u0103 \u015fi care prime\u015fte ca parametru o referin\u0163\u0103 la un obiect al clasei respective are acces:\n\n", "answers": [" doar la membrii publici;\n", " la toti membrii;\n", " la membrii public \u015fi protected;\n", " la membrii private;\n", " la toti membrii, dar \u00eel poate doar consulta, nu \u015fi modifica.\n"], "correct_answers": [1]}, {"question": " O func\u0163ie independent\u0103 declarat\u0103 friend \u00een domeniul public dintr - o clas\u0103 \u015fi care prime\u015fte ca parametru o referin\u0163\u0103 la un obiect al clasei respective are acces:\n\n", "answers": [" doar la membrii publici;\n", " la toti membrii;\n", " la membrii public \u015fi protected;\n", " la membrii private;\n", " la toti membrii, dar \u00eel poate doar consulta, nu \u015fi modifica."], "correct_answers": [1]}, {"question": " Fie urm\u0103torul program:\n\n  #include <iostream> using namespace std; class c{\n\n  int a;\n\npublic:\n  c() {}\nc(const c & );\nc & operator = (c & );\n};\nc & c::operator = (c & c) {\n  cout << endl << \"copiere cu egal\";\n  return c;\n}\nc::c(const c & c) {\n  cout << endl << \"Constructor de copiere\";\n}\nint main() {\n  c x, y = x;\n  c b = x;\n  x = y;\n};\n\nProgramul:\n\n", "answers": [" apeleaza de doua ori operator = (), o data constructorul de copiere si o data constructorul implicit;\n", " apeleaza de trei ori constructorul de copiere, o data constructorul implicit;\n", " apeleaza de trei ori supraincarcarea operatorului = ;\n", " apeleaza de doua ori constructorul de copiere si de trei ori operator = ();\n", " apeleaza de doua ori constructorul de copiere, o data operator = () si o data constructorul implicit;\n"], "correct_answers": [4]}, {"question": " De c\u00e2te ori este apelat destructorul clasei Persoana \u00een programul urm\u00e3tor ?\n\n  #include <iostream> using namespace std; class Persoana{ public:\n\n  Persoana() {\n    cout << \"Constructor\" << endl;\n  }\n  ~Persoana() {\n    cout << \"Destructor\" << endl;\n  }\n};\nint main() {\n  Persoana ** ppp;\n  ppp = new Persoana * [5];\n  for (int i = 0; i < 5; i++)\n    ppp[i] = new Persoana();\n  for (int i = 0; i < 5; i++)\n    delete ppp[i];\n}\n\nR\u0103spuns:\n", "answers": ["10;\n", "6;\n", "7;\n", " 5;\n", "niciunul din r\u0103spunsurile anterioare.\n"], "correct_answers": [3]}, {"question": " \u00cen programul urm\u00e3tor:\n\n  #include <iostream> using namespace std; class Persoana{\n\n  int varsta;\n\nchar * nume;\npublic:\n  Persoana(int v = 0, char * n = \"Oarecare\"): varsta(v) {\n    this -> nume = new char[strlen(n) + 1];\n    strcpy(this -> nume, n);\n    cout << \"Constructor\" << endl;\n  }\nPersoana(Persoana & p) {\n  this -> varsta = p.varsta;\n  this -> nume = new char[strlen(p.nume) + 1];\n  strcpy(this -> nume, p.nume);\n  cout << \"Constructor de copiere\" << endl;\n}\nvoid operator = (Persoana & p) {\n    this -> varsta = p.varsta;\n    delete[] this -> nume;\n    this -> nume = new char[strlen(p.nume) + 1];\n    strcpy(this -> nume, p.nume);\n    cout << \"Operator=\" << endl;\n  }\n  ~Persoana() {\n    cout << \"Destructor\" << endl;\n  }\n};\n\nint main() {\n  Persoana p1, p2(20, \"Gigel\");\n  Persoana p3 = p1;\n  p3 = p2;\n  Persoana p4 = p1;\n}\n\nSunt apelate urm\u00e3toarele:\n", "answers": ["constructor\u2013 de patru ori, constructor de copiere\u2013 o dat\u00e3, destructor\u2013 de patru ori;\n", "constructor\u2013 de trei ori, constructor de copiere - de dou\u00e3 ori, destructor de cinci ori;\n", " constructor\u2013 de dou\u00e3 ori, constructor de copiere\u2013 de dou\u00e3 ori, operator = -o dat\u00e3, destructor\u2013 de patru ori;\n", "constructor\u2013 de dou\u00e3 ori, constructor de copiere\u2013 o dat\u00e3, operator = -de dou\u00e3 ori, destructor\u2013 de dou\u00e3 ori;\n", "constructor\u2013 de dou\u00e3 ori, constructor de copiere\u2013 o dat\u00e3, operator = -de dou\u00e3 ori, destructor\u2013 de patru ori."], "correct_answers": [2]}]