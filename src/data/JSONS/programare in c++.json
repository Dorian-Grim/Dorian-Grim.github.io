[
  {
    "questionNumber": "1.",
    "question": "Fie secvența:\n\nclass cls{\n        public:\n              cls(){ cout&lt;&lt;\"constructor\";}\n              cls(cls &c){cout&lt;&lt;\"constructor de copiere\";}\n};\nint f(cls c){ return 1;}\nint main(){\n    cls c;\n    f(c);\n    return 0;\n}\n\nÎn momentul executării programului de mai sus:",
    "answers": [
      "constructorul de clasă se apelează o dată, iar cel de copiere nu se apelează;",
      "constructorul de clasă şi cel de copiere se apelează fiecare câte o dată;",
      "constructorul de copiere se apelează o dată, iar cel de clasă nu se apelează;",
      "constructorul de clasă se apelează de două ori, iar cel de copiere nicio dată;",
      "constructorul de clasă și cel de copiere se apelează fiecare de câte două ori."
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "2.",
    "question": "Fie secvența:\n\nclass cls{\n          public:\n                cls(){ cout&lt;&lt;\"constructor\";}\n                cls(cls &c){cout&lt;&lt;\"constructor de copiere\";}\n};\nint f(cls &c){ return 1;}\nint main(){\n    cls c;\n    f(c);\n    return 0;\n}\n\nÎn momentul executării programului de mai sus:",
    "answers": [
      "constructorul clasei se apelează o dată, iar cel de copiere nu se apelează nicio dată;",
      "constructorul de clasă şi cel de copiere se apelează fiecare câte o dată;",
      "constructorul de copiere se apelează o dată, iar cel de clasă nu se apelează;",
      "constructorul clasei se apelează de două ori, iar cel de copiere nicio dată;",
      "constructorul de clasă și cel de copiere se apelează fiecare de câte două ori."
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "3.",
    "question": "Fie secvența:\nclass C{\n          int a;\n          public:\n                  virtual void metoda1()=0;\n                  virtual void metoda2()=0;\n};\nint main(){\n    C *pob;            //declarația 1\n    C ob;                //declarația 2\n    C *vpob[5];      //declarația 3\n    C vob[5];          //declarația 4\n    return 0;\n}\n\nDeclarațiile admise în acest caz sunt:",
    "answers": [
      "Declarațiile 1 și 2;",
      "Declarația 1;",
      "Declarațiile 2 și 4;",
      "Declarația 3;",
      "Declarațiile 1, 2 și 3."
    ],
    "correct_answers": [2, 4]
  },
  {
    "questionNumber": "4.",
    "question": "Fie clasa :\n\nclass c {\n    int a, b ;\n    public :\n            c (int , int ) ;\n              int det_a ( ) {return a ;}\n            ~c () ;\n};\n\nSemnul ~ are rolul :",
    "answers": [
      "de a nega pe biți rezultatul returnat de metoda c( );",
      "de a preciza existența destructorului;",
      "de a nega logic rezultatul returnat de metoda c( );",
      "de a supraîncarca constructorul clasei;",
      "de a supraîncarca operatorul ~"
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "5.",
    "question": "Secvenţa următoare:\n\nclass c1{\n          public:\n              int a;\n              c1(int y){ a=y;cout&lt;&lt;\"constructor 1\";}\n              ~c1(){cout&lt;&lt;\"destructor 2\";}\n};\nclass c2:public c1{\n          public:\n              int b;\n              c2(int y, int x):c1(y) { b=x; cout&lt;&lt;\"constructor 2\";}\n              ~c2(){cout&lt;&lt;\"destructor 2\";}\n};\nint main(){\n    c1 ob1(2);\n    c2 ob2(2,3);\n    return 0;\n}\n\nafișează:",
    "answers": [
      "constructor 1 constructor 2 destructor 2 destructor 1",
      "constructor 1 constructor 1 constructor 2 destructor 2 destructor 1 destructor 1",
      "constructor 1 constructor 2 constructor 1 destructor 1 destructor 2 destructor 1",
      "constructor 1 constructor 1 constructor 2 destructor 2 destructor 1"
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "6.",
    "question": "Fie următorul program C++:\n\n#include &lt;iostream.h>\nclass B{\n          public:\n                B(){cout&lt;&lt;\"B()\"&lt;&lt;endl;}\n                ~B(){cout&lt;&lt;\"~B()\"&lt;&lt;endl;}\n};\nclass D: public B{\n          public:\n                D(){cout&lt;&lt;\"D()\"&lt;&lt;endl;}\n                ~D(){cout&lt;&lt;\"~D()\"&lt;&lt;endl;}\n};\nint main(){\n    B *b=new B();\n    delete b;\n    b=new D();\n    delete b;\nreturn 0;\n}\n\nProgramul afișează:",
    "answers": [
      "B() ~B() B() D() ~D()",
      "B() ~B() B() D() ~B()",
      "B() ~B() B() ~B()",
      "B() ~B() D() ~B()"
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "7.",
    "question": "Fie programul:\n\n#include &lt;iostream.h>\nclass B{\n          public:\n              B(){cout&lt;&lt;\"B()\"&lt;&lt;endl;}\n              B(B &b){cout&lt;&lt;\"B(B &b)\"&lt;&lt;endl;}\n};\nclass D: public B{\n          public:\n              D(){cout&lt;&lt;\"D()\"&lt;&lt;endl;}\n              D(D &d){cout&lt;&lt;\"D(D &d)\"&lt;&lt;endl;}\n};\nint main(){\n    B b;\n    B b1(b);\n    D d;\n    D d1(d);\n    return 0;\n}\n\nProgramul afișează:",
    "answers": [
      "B() B(B&b) B() D() B(B &b) D(D &d)",
      "B() B() B(B&b) B() D() B(B &b) D() B(B &b)",
      "B() B(B&b) D() B(B &b) D() B(B &b)",
      "B() B(B&b) B() D() B() D(D &d)"
    ],
    "correct_answers": [4]
  },
  {
    "questionNumber": "8.",
    "question": "Fie clasa :\n\nclass c {\n    int a,b;\n    public:\n            float c (int, int)\n            int get_a {return a;}\n            c ();\n            };\n\nDeclaraţia float c(int, int) ar putea corespunde unui constructor al clasei?",
    "answers": [
      "da, fiind o supraîncarcare a celui existent;",
      "nu, deoarece crează ambiguitate;",
      "nu, deoarece constructorul nu are tip returnat;",
      "nu, deoarece nu este de tip friend."
    ],
    "correct_answers": [3]
  },
  {
    "questionNumber": "9.",
    "question": "Fie secvenţa următoare:\n\nclass persoana{\n          int varsta;\n          public:\n                persoana(int v=18){varsta=v;}\n                persoana& operator++(int){varsta++; return *this;}\n                int get_varsta(){return varsta;}\n};\nint main(){\n    persoana p(20);\n    cout&lt;&lt;p++.get_varsta();\n    return 0;\n}\n\nSecvența afișează:",
    "answers": ["21", "20", "18", "19"],
    "correct_answers": [1]
  },
  {
    "questionNumber": "10.",
    "question": "O funcție declarată friend în clasa de bază:",
    "answers": [
      "rămâne friend în clasa derivată, pentru partea moștenită;",
      "are acces pe toată clasa derivată;",
      "nu are acces pe zonele private și protected ale clasei derivate;",
      "nu are acces pe zona private a clasei derivate;",
      "are acces pe zonele public și protected ale clasei derivate"
    ],
    "correct_answers": [3, 4]
  },
  {
    "questionNumber": "11.",
    "question": "Se consideră următoarea secvență de program:\n\nclass B{\n          private:\n                  int x,y;\n          public:\n                  B(int a,int b){ x=a;y=b; }\n                  B(const B &a){ x=a.x; y=a.y;}\n};\n\nÎn care dintre următoarele situații se realizează copierea unui obiect într-altul:",
    "answers": [
      "B c1(4,5);",
      "B c2(0.0, 0,0);",
      "B c1, c3=c1;",
      "B c4(1);",
      "B c1, c5(c1)."
    ],
    "correct_answers": [3, 5]
  },
  {
    "questionNumber": "12.",
    "question": "Fie următorul program:\n\n      #include&lt;iostream.h>\n        class cls {\n                  static int i;\n                  int j;\n                  public:\n                            cls(int x=7) { j=x; }\n                            static int imp(int k){ cls a; return i+k+a.j; } };\n        int cls::i;\n        int main()\n        { int k=5;\n        cout&lt;&lt;cls::imp(k);\n        return 0;\n        }\n\nIndicați ce se va afișa pe ecran în urma executării programului:",
    "answers": ["11", "13", "12", "14"],
    "correct_answers": [3]
  },
  {
    "questionNumber": "13.",
    "question": "Fie următorul program:\n\n#include &lt;iostream.h>\nclass B{\n          public:\n                virtual void f() { cout&lt;&lt;\"B::f() \";}\n                void g() { cout&lt;&lt;\"B::g() \";}\n};\n\nclass D: public B{\n          public:\n                void f() { cout&lt;&lt;\"D::f() \";}\n                void g() { cout&lt;&lt;\"D::g() \";}\n};\nint main(){\n    int i;\n    B *a=new B();\n    B *b=new D();\n    a->f(); b->f();\n    a->g(); b->g();\n    return 0;\n}\n\nIndicați ce se va afișa pe ecran în urma executării programului:",
    "answers": [
      "D::f() B::f() B::g() B::g() B::g()",
      "B::f() D::f() B::g() B::g()",
      "B::f() D::f() B::g() D::g()",
      "B::f() B::g() D::f() D::g()"
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "14.",
    "question": "Fie următorul program:\n\n#include &lt;iostream.h>\nclass B{\n          public:\n                virtual void f() { cout&lt;&lt;\"B::f() \";}\n                void g() { cout&lt;&lt;\"B::g() \";}\n};\n\nclass D1: public B{\n          public:\n                void f() { cout&lt;&lt;\"D1::f() \";}\n                void g() { cout&lt;&lt;\"D1::g() \";}\n};\nclass D2: public B{\n          public:\n                void g() { cout&lt;&lt;\"D2::g() \";}\n};\nint main(){\n    int i;\n    B *a=new B();\n    B *b=new D1();\n    B *c=new D2();\n    a->f(); b->f(); c->f();\n    a->g(); b->g(); c->g();\n    return 0;\n}\n\nIndicați ce se va afișa pe ecran în urma executării programului:",
    "answers": [
      "B::f() D1::f() B::f() B::g() B::g() B::g()",
      "D2::f() D1::f() B::f() B::g() B::g() B::g()",
      "B::f() D1::f() D::f() B::g() D1::g() D2::g()",
      "B::f() D1::f() B::f() B::g() D1::g() D2::g()",
      "B::f() B::f() D2::f() B::g() B::g() D2::g()"
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "15.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass salariat{\n          int varsta;\n          public:\n                salariat (int v=20) {varsta =v;}\n                operator int() { return varsta;}\n                salariat& operator++(){varsta++; return *this;}\n                salariat operator++ (int) { varsta++; return *this;}\n};\nint main(){\n     salariat s(21);\n     int a=s++, b=++s;\n     cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl;\n     return 0;\n}\n\nProgramul afișează:",
    "answers": ["20 21", "21 22", "22 23", "20 22", "21 23"],
    "correct_answers": [3]
  },
  {
    "questionNumber": "16.",
    "question": "Fie următorul program:\n\n#include &lt;iostream.h>\nclass Cerc{\n          public:\n                float raza;\n                Cerc(float r){raza=r;}\n                float get_raza(){return raza;}\n                Cerc operator++(){raza++; return *this;}\n                Cerc operator--(){raza--; return *this;}\n};\nint main(){\n    Cerc c(3.5);\n    cout&lt;&lt;(++(++c)).get_raza()&lt;&lt;\" \";\n    cout&lt;&lt;c.get_raza()&lt;&lt;\" \";\n    cout&lt;&lt;(--(--c)).get_raza()&lt;&lt;\" \";\n    cout&lt;&lt;c.get_raza()&lt;&lt;\" \";\n    return 0;\n}\n\nProgramul afișează:",
    "answers": [
      "3.5 4.5 2.5 3.5",
      "5.5 4.5 2.5 2.5",
      "2.5 5.5 4.5 3.5",
      "5.5 4.5 2.5 3.5",
      "4.5 2.5 3.5 5.5"
    ],
    "correct_answers": [4]
  },
  {
    "questionNumber": "17.",
    "question": "O metodă statică a unui obiect se caracterizează prin faptul că:",
    "answers": [
      "nu primește pointerul la obiect this;",
      "folosește numai datele publice;",
      "se poate apela prin numele clasei;",
      "nu poate fi definita decât inline;",
      "daca prelucrează obiecte, primește obiectele ca parametrii expliciți."
    ],
    "correct_answers": [1, 3, 5]
  },
  {
    "questionNumber": "18.",
    "question": "Fie secvența de program:\n\n#include &lt;iostream.h>\nclass C{\n          public:\n                static int s;\n};\nint C::s=0;\nint main(){\n    int a=7; C::s=a;\n    cout&lt;&lt;C::s;\n    return 0;\n}\n\nÎn secvența de mai sus, inițializarea lui s este:",
    "answers": [
      "ilegală, deoarece nu există niciun obiect creat;",
      "ilegală, deoarece s este inițializat în afara clasei;",
      "ilegală, deoarece s este dublu definit, în clasă și în afara ei;",
      "ilegală, deoarece datele statice pot fi doar private;",
      "corectă, deoarece membri statici există înainte de a se crea obiecte din clasă."
    ],
    "correct_answers": [5]
  },
  {
    "questionNumber": "19.",
    "question": "Fie secvența:\n\nclass complex{\n          double re;\n          double im;\n          public:\n                complex(double x=1.0,double y=6.80){re=x; im=y;}\n                complex( const complex &u){re=u.re;im=u.im;}\n};\n\nPrecizaţi în ce situaţie se utilizează constructorul de copiere:",
    "answers": [
      "complex z1(5.2, 3.6);",
      "complex z1(5.2, 3.6), z2=z1;",
      "complex z3(0.1,1.0);",
      "complex z1(5.2, 3.6), z4(z1);",
      "complex z5(-0.1,28.7)."
    ],
    "correct_answers": [2, 4]
  },
  {
    "questionNumber": "20.",
    "question": "Fie secvența :\n\nclass A1{\n         public:\n              A1(){cout &lt;&lt; \"A1 \";}\n};\nclass A2{\n         public:\n              A2(){cout &lt;&lt; \"A2 \";}\n};\nclass AA1 : public A1, virtual public A2{\n         public:\n              AA1(){cout &lt;&lt; \"AA1 \";}\n};\nclass AA2 : public A1, virtual A2{\n         public:\n              AA2(){cout &lt;&lt; \"AA2 \";}\n};\nclass B : public AA1, virtual public AA2{\n         public:\n              B(){cout &lt;&lt; \"B \";}\n};\nint main(){\n    B ob1;\n    return 0;\n}\n\nSecvența afișează:",
    "answers": [
      "A1 A2 AA2 A1 AA1 B",
      "A2 A2 AA2 AA1 A1 B",
      "A1 A2 AA2 A1 B AA1",
      "A2 A1 AA2 A1 AA1 B",
      "A2 A1 A2 AA1 A1 B"
    ],
    "correct_answers": [4]
  },
  {
    "questionNumber": "21.",
    "question": "Care dintre afirmațiile următoare sunt adevărate?",
    "answers": [
      "precedența unui operator poate fi modificată prin redefinire;",
      "aritatea unui operator nu poate fi modificată prin redefinire;",
      "asociativitatea unui operator poate fi modificată prin redefinire;",
      "semnificația modului în care lucrează un operator asupra obiectelor de tipuri predefinite nu\npoate fi schimbată prin redefinire."
    ],
    "correct_answers": [2, 4]
  },
  {
    "questionNumber": "22.",
    "question": "Care dintre afirmațiile următoare sunt adevărate?",
    "answers": [
      "funcțiile inline nu pot fi funcții virtuale;",
      "constructorii pot fi funcții virtuale;",
      "orice funcție membru statică este funcție virtuală;",
      "destructorul poate fi funcție virtuală."
    ],
    "correct_answers": [1, 4]
  },
  {
    "questionNumber": "23.",
    "question": "Fie programul:\n\n#include &lt;iostream.h>\nclass Cerc{\n          float raza;\n          public:\n                Cerc(float r){raza=r;}\n                float get_raza(){return raza;}\n                void operator++(){raza++;}\n};\nclass Cilindru : public Cerc{\n          float inaltime;\n          public:\n                Cilindru(float raza, float i):Cerc(raza){inaltime=i;}\n                void operator++(){inaltime++;}\n                float get_inaltime(){return inaltime;}\n};\nint main(){\n          Cerc *pc;\n          Cilindru c(2,6);\n          pc=&c;\n          ++ *pc;\n          cout&lt;&lt;pc->get_raza()&lt;&lt;\" \"&lt;&lt;c.get_inaltime()&lt;&lt;endl;\n          return 0;\n}\n\nProgramul afișează:",
    "answers": ["2 5", "2 6", "3 6", "2 5"],
    "correct_answers": [3]
  },
  {
    "questionNumber": "24.",
    "question": "Care dintre afirmațiile următoare sunt false?",
    "answers": [
      "obiectele unei clase derivate au acces la membrii privați ai clasei sale de bază;",
      "relația de moștenire este tranzitivă;",
      "funcțiile friend ale clasei de bază se moștenesc de către clasa derivată;",
      "constructorul și destructorul clasei de bază se moștenesc în clasa derivată"
    ],
    "correct_answers": [1, 3, 4]
  },
  {
    "questionNumber": "25.",
    "question": "Fie următorul program:\n\n#include&lt;ostream.h>\nclass persoana{\n          int varsta, salariul;\n          friend ostream & operator&lt;&lt;(ostream &out,persoana p){\n                  out&lt;&lt;p.varsta&lt;&lt;\" \"&lt;&lt;p.salariul; return out;\n          }\n          public:\n                persoana(int v){varsta=v;salariul=0;}\n                persoana(){varsta=0;salariul=0;}\n};\nint main(){\n    persoana p(1);cout&lt;&lt;p;\n    return 0;\n}\n\nProgramul afișează:",
    "answers": ["1 0", "0 0", "1 1", "0 1"],
    "correct_answers": [1]
  },
  {
    "questionNumber": "26.",
    "question": "Supraîncărcarea unor operatori se poate realiza prin funcţii operator sau prin funcţii friend.\nDiferența dintre aceste două posibilități constă în:",
    "answers": [
      "lista de parametri;",
      "obiectul returnat;",
      "precedența operatorilor;",
      "aritatea operatorului."
    ],
    "correct_answers": [1, 3]
  },
  {
    "questionNumber": "27.",
    "question": "Fie programul:\n\nclass c{\n          int a;\n          public:\n                c(){};\n                c(const c&){};\n                void operator=(c&){};\n};\nint main(){\n          c a;\n          c b=a;\n}\n\nLinia de cod c b=a; determină:",
    "answers": [
      "executarea constructorului de copiere;",
      "executarea metodei prin care se supraîncărcă operatorul =;",
      "executarea atât a constructorului de copiere, cât și a metodei operator =;",
      "o eroare, deoarece nu este permisă combinarea atribuirii cu o declarație;",
      "executarea constructorului implicit."
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "28.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass cls{\n          public:\n                ~cls(){cout&lt;&lt;\"\\n Destructor\";}\n};\nint main(){\n    cls *po=new cls[3];\n    delete []po;\n}\n\nDestructorul clasei:",
    "answers": [
      "nu se apelează nicio dată;",
      "se apelează o dată;",
      "se apelează de trei ori;",
      "se apelează de patru ori."
    ],
    "correct_answers": [3]
  },
  {
    "questionNumber": "29.",
    "question": "O funcție independentă declarată friend în domeniul public dintr-o clasă și care primește ca parametru o referință la un obiect al clasei respective are acces:",
    "answers": [
      "doar la membrii declarați public;",
      "la toți membrii;",
      "la membrii public și la cei protected;",
      "la membrii protected."
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "30.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass A{\n          int a[3];\n          public:\n                A(int i, int j, int k){a[0]=i; a[1]=j; a[2]=k;}\n                int& operator[](int i){return a[i];}\n};\nint main(){\n    A ob(1,2,3); cout&lt;&lt;ob[1];\n    ob[1]=25; cout&lt;&lt;ob[1];\n    return 0;\n}\n\nCe se poate afirma despre operator[]()?",
    "answers": [
      "produce supraîncărcarea unei funcţii;",
      "produce supraîncărcarea unui operator unar;",
      "supraîncarcă operatorul [];",
      "este o funcţie membru oarecare a clasei A, care nu produce supraîncărcarea unui operator;",
      "reprezintă un operator ternar."
    ],
    "correct_answers": [3]
  },
  {
    "questionNumber": "31.",
    "question": "Considerăm următorul program:\n\n#include&lt;iostream.h>\nclass C{\n          public:\n                int x;\n                C(int v) { x=v;}\n                double operator+(C &c, double d){return c.x+d;}\n                double operator+(double d, C &c){return c.x+d;}\n};\nint main() {\n    C c(5);\n    cout&lt;&lt;2+c+3;\n    return 0;\n}\n\nStabiliți care dintre următoarele afirmații sunt adevărate:",
    "answers": [
      "supraîncărcările operator + () trebuie să fie friend;",
      "supraîncărcările operator+() nu se justifică deoarece au același cod;",
      "programul afișează 10;",
      "supraîncărcările operator+() trebuie să returneze referințe."
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "32.",
    "question": "Fie programul:\n\n#include&lt;iostream.h>\nclass c1{ int a;};\nclass c2:public c1{\n          public:\n                int b;\n                void scrie_a( ) { cout&lt;&lt;a; }\n};\nint main(){\n    c2 ob; ob.scrie_a();\n    return 0;\n}\n\nSelectaţi afirmaţia corectă:",
    "answers": [
      "funcția scrie_a( ) nu are acces asupra unui membru privat;",
      "programul afișează valoarea lui a;",
      "derivarea publică este incorect realizată;",
      "prin derivare publică, accesul la membrii moşteniţi devine public."
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "33.",
    "question": "Fie programul următor:\n\n#include&lt;iostream.h>\nclass B{\n          int x;\n          public:\n                B(int i=10) { x=i;}\n                int get_x() { return x; }\n};\nclass D: public B{\n          public:\n                D(int i):B(i){}\n                D operator+(const D& a) {return x+a.x; }\n};\nint main(){\n    D ob1(7), ob2(-12);\n    cout&lt;&lt;(ob1+ob2).get_x();\n    return 0;\n}\n\nProgramul afișează:",
    "answers": [
      "eroare, clasa B nu poate fi moștenită de clasa D;",
      "eroare, metoda operator nu are acces la un membru privat al clasei de bază;",
      "programul afișează valoarea -5;",
      "eroare, operatorul + nu se poate aplica pentru tipuri abstracte de date."
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "34.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass B1{int x;};\nclass B2{int y;};\nclass B3{int z;};\nclass B4{int t;};\nclass D: public B1, private B2, protected B3,B4 {public : int m;};\nint main(){\n    D d;\n    cout&lt;&lt;d.m;         //varianta 1\n    cout&lt;&lt;d.x;          //varianta 2\n    cout&lt;&lt;d.y;          //varianta 3\n    return 0;\n}\n\nVariantele care permit accesul la variabile pentru afișare sunt:",
    "answers": ["1+3;", "1+2;", "1+2+3;", "1"],
    "correct_answers": [4]
  },
  {
    "questionNumber": "35.",
    "question": "Considerăm următorul program:\n\nclass vector{\n          int * pe, nr_c;\n          public:\n                operator int (){return nr_c;}\n                vector(int);\n};\nvector::vector(int n){\n    pe=new int[n]; nr_c=n;\n    while(n--) pe[n]=n;\n}\nvoid f(int i){cout&lt;&lt;i&lt;&lt;endl;}\n    int main(){\n    vector x(10);\n    f(x);\n    return 0;\n}\n\nProgramul afişează:",
    "answers": ["9", "10", "numerele de la 1 la 10", "numerele de la 0 la 9"],
    "correct_answers": [2]
  },
  {
    "questionNumber": "36.",
    "question": "Considerăm următorul program:\n\nclass c{\n          int a;\n          public:\n                virtual void metoda1()=0;\n                virtual void metoda2(int)=0;\n};\nint main{\n    c *pob;               //declaraţia 1\n    c ob;                   //declaraţia 2\n    c *vpob[3];         //declaraţia 3\n    c vob[3];             //declaraţia 4\n    return 0;\n}\n\nDeclaraţiile admise:",
    "answers": ["1+2;", "1+2+3+4", "nici una", "1+3;"],
    "correct_answers": [4]
  },
  {
    "questionNumber": "37.",
    "question": "Fie data urmatoarea ierarhie:\n\nclass B {… }\nclass D1:B{…}\nclass D2:B{…}\nclass M1:D1, public D2{…}\nclass M2:virtual D1, virtual D2 {…}\n\nConsiderăm următoarele afirmaţii:\n      1. clasa M1 va moşteni un obiect de tip B;\n      2. clasa M1 va moşteni două obiecte de tip B;\n      3. clasa M2 va va moşteni un obiect de tip B;\n      4. clasa M2 va moşteni două obiecte de tip B.\n\nPrecizaţi care dintre afirmaţiile de mai sus sunt corecte:",
    "answers": ["2+3", "1+2", "1+3", "2+4"],
    "correct_answers": [1]
  },
  {
    "questionNumber": "38.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass B{\n          public:\n                int x;\n                B(int i=16) { x=i; }\n                B f(B ob) { return x+ob.x; }\n};\nclass D: public B{\n          public:\n                D(int i=25) { x=i; }\n                B f(B ob) { return x+ob.x+1; }\n                void afisare(){ cout&lt;&lt;x; }\n};\nint main(){\n     B *p1=new D, *p2=new B, *p3=new B(p1->f(*p2));\n     cout&lt;&lt;p3->x;\n     return 0;\n}\n\nProgramul afişează:",
    "answers": [
      "41",
      "eroare, nu se poate instanţia un obiect al unei clase derivate printr-un pointer la un obiect de tip clasa de bază;",
      "44",
      "45"
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "39.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass B{\n          int i;\n          public:\n                static int x;\n                B() { x++; i=1; }\n                ~B() { x--; }\n                static int get_x() { return x; }\n                int get_i() { return i; }\n};\nint B::x;\nclass D: public B{\n          public:\n                D() { x++; }\n                ~D() { x--; }\n};\nint f(B *q){ return (q->get_i())+1;}\nint main(){\n    B *p=new B;\n    cout&lt;&lt;f(p);\n    delete p;\n    p=new D;\n    cout&lt;&lt;f(p);\n    delete p;\n    cout&lt;&lt;D::get_x();\n    return 0;\n}\n\nProgramul afişează:",
    "answers": [
      "eroare, data membră statică x nu este iniţializată;",
      "eroare, metoda get_x() nu poate fi declarată static;",
      "programul afişează valoarea 221;",
      "programul afişează valoarea 220."
    ],
    "correct_answers": [3]
  },
  {
    "questionNumber": "40.",
    "question": "Fie următorul program:\n\n#include &lt;iostream.h>\ntemplate&lt;class T, class E>\nfloat f(T x, E y){ return x+y;}\nfloat g(int x, float y){ return x-y;}\nint main(){\n          int a=5;\n          float b=8.6;\n          cout&lt;&lt;g(a,b);\n          return 0;\n}\n\nProgramul afişează:",
    "answers": [
      "3",
      "eroare, parametrizarea clasei T este incorrect realizată",
      "13.6",
      "-3.6"
    ],
    "correct_answers": [4]
  },
  {
    "questionNumber": "41.",
    "question": "Fie următorul program:\n\n#include &lt;iostream.h>\ntemplate&lt;class T>\nint f(T x, T y){ return x+y;}\nint f(int x, int y){ return x-y;}\nint main(){\n    int a=5;\n    float b=8.6;\n    cout&lt;&lt;f(a,b);\n    return 0;\n}\n\nProgramul afişează:",
    "answers": [
      "-3",
      "eroare, parametrizarea clasei T este incorrect realizată",
      "13.6",
      "3.6"
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "42.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass B{\n    int x;\n    public:\n              B(int i=10) { x=i; }\n              int get_x() { return x; }};\nclass D: public B{\n    public:\n              D(int i):B(i) {}\n              D operator+(const D& a) {return x+a.x; }};\nint main()\n{ D ob1(7), ob2(-12);\n    cout&lt;&lt;(ob1+ob2).get_x();\n    return 0;\n}\n\nIndicați ce se va afișa pe ecran în urma executării programului:",
    "answers": [
      "-5",
      "-4",
      "eroare, în clasa derivată D nu se poate accesa data membră privată x a clasei B",
      "-3"
    ],
    "correct_answers": [3]
  },
  {
    "questionNumber": "43.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass B{\npublic:\n      int x;\n      B(int i=16) { x=i; }\n      B f(B ob) { return x+ob.x; } };\nclass D: public B{\npublic:\n      D(int i=25) { x=i; }\n      B f(B ob) { return x+ob.x+1; }\n      void afisare(){ cout&lt;&lt;x; } };\nint main()\n{\n      B *p1=new D, *p2=new B, *p3=new B(p1->f(*p2));\n      cout&lt;&lt;p3->x;\n      return 0;\n}\n\nProgramul afişează:",
    "answers": [
      "41",
      "eroare, în clasa derivată D nu se poate accesa data membră x a clasei B",
      "16",
      "25"
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "44.",
    "question": "Fie următorul program:\n\n#include&lt;iostream.h>\nclass cls1{\n          public:\n                int a;\n                cls1() { a=7; }\n};\nclass cls2{\n          public:\n                int b;\n                cls2(int i) { b=i; }\n                cls2(cls1& x) { b=x.a; }\n};\nint main(){\n    cls1 x;\n    cout&lt;&lt;x.a;\n    cls2 y(x);\n    cout&lt;&lt;y.b;\n    return 0;\n}\n\nProgramul afişează:",
    "answers": [
      "7 7",
      "eroare, constructorul de copiere nu este corect definit",
      "eroare, constructorul de copiere nu poate accesa o dată publică a clasei cls1",
      "78"
    ],
    "correct_answers": [1]
  },
  {
    "questionNumber": "45.",
    "question": "O funcţie friend diferă de o metodă obişnuită a unei clase prin faptul că:",
    "answers": [
      "nu se poate defini inline;",
      "nu primeşte pointerul implicit la obiect this;",
      "nu poate accesa decât partea publică a obiectului;",
      "se foloseşte doar pentru supraîncărcarea operatorilor;",
      "nu poate returna valori."
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "46.",
    "question": "O funcţie independentă declarată friend în domeniul private dintr-o clasă şi care primeşte ca parametru o referinţă la un obiect al clasei respective are acces:",
    "answers": [
      "doar la membrii publici;",
      "la toti membrii;",
      "la membrii public şi protected;",
      "la membrii private;",
      "la toti membrii, dar îl poate doar consulta, nu şi modifica."
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "47.",
    "question": "O funcţie independentă declarată friend în domeniul public dintr-o clasă şi care primeşte ca parametru o referinţă la un obiect al clasei respective are acces:",
    "answers": [
      "doar la membrii publici;",
      "la toti membrii;",
      "la membrii public şi protected;",
      "la membrii private;",
      "la toti membrii, dar îl poate doar consulta, nu şi modifica."
    ],
    "correct_answers": [2]
  },
  {
    "questionNumber": "48.",
    "question": "Fie următorul program:\n\n#include &lt;iostream>\nusing namespace std;\nclass c{\n  int a;\n  public :\n          c() {}\n          c(const c&);\n          c& operator =(c&);};\nc& c::operator=(c &c){ cout &lt;&lt; endl &lt;&lt; \"copiere cu egal\"; return c;}\nc::c(const c &c) { cout &lt;&lt; endl &lt;&lt; \"Constructor de copiere\"; }\nint main()\n{\n  c x,y=x;\n  c b=x; x=y;\n};\n\nProgramul:",
    "answers": [
      "apeleaza de doua ori operator=(), o data constructorul de copiere si o data constructorul\nimplicit;",
      "apeleaza de trei ori constructorul de copiere, o data constructorul implicit;",
      "apeleaza de trei ori supraincarcarea operatorului =;",
      "apeleaza de doua ori constructorul de copiere si de trei ori operator=();",
      "apeleaza de doua ori constructorul de copiere, o data operator=() si o data constructorul\nimplicit;"
    ],
    "correct_answers": [5]
  },
  {
    "questionNumber": "49.",
    "question": "De câte ori este apelat destructorul clasei Persoana în programul urmãtor?\n\n#include &lt;iostream>\nusing namespace std;\nclass Persoana{\npublic:\n          Persoana() {cout&lt;&lt;\"Constructor\"&lt;&lt;endl;}\n          ~Persoana() {cout&lt;&lt;\"Destructor\"&lt;&lt;endl;}};\nint main(){\n          Persoana** ppp;\n          ppp = new Persoana*[5];\n          for(int i=0; i&lt;5; i++)\n          ppp[i] = new Persoana();\n          for(int i=0; i&lt;5; i++)\n          delete ppp[i];\n}\n\nRăspuns:",
    "answers": [
      "10;",
      "6;",
      "7;",
      "5;",
      "niciunul din răspunsurile anterioare."
    ],
    "correct_answers": [4]
  },
  {
    "questionNumber": "50.",
    "question": "În programul urmãtor:\n\n#include &lt;iostream>\nusing namespace std;\nclass Persoana{\n          int varsta;\n          char* nume;\n          public:\n                    Persoana(int v=0, char* n=\"Oarecare\"):varsta(v){\n                                this->nume = new char[strlen(n)+1];\n                                strcpy(this->nume,n);\n                                cout&lt;&lt;\"Constructor\"&lt;&lt;endl;}\n                    Persoana(Persoana& p){\n                                this->varsta = p.varsta;\n                                this->nume = new char[strlen(p.nume)+1];\n                                strcpy(this->nume, p.nume);\n                                cout&lt;&lt;\"Constructor de copiere\"&lt;&lt;endl;}\n                    void operator=(Persoana& p){\n                                this->varsta = p.varsta;\n                                delete[] this->nume;\n                                this->nume = new char[strlen(p.nume)+1];\n                                strcpy(this->nume, p.nume);\n                                cout&lt;&lt;\"Operator=\"&lt;&lt;endl;}\n                    ~Persoana(){ cout&lt;&lt;\"Destructor\"&lt;&lt;endl;}};\n\nint main()\n{\n          Persoana p1, p2(20, \"Gigel\");\n          Persoana p3 = p1;\n          p3 = p2;\n          Persoana p4 = p1;\n}\n\nSunt apelate urmãtoarele:",
    "answers": [
      "constructor – de patru ori, constructor de copiere – o datã, destructor – de patru ori;",
      "constructor – de trei ori, constructor de copiere - de douã ori, destructor de cinci ori;",
      "constructor – de douã ori, constructor de copiere – de douã ori, operator= - o datã, destructor – de patru ori;",
      "constructor – de douã ori, constructor de copiere – o datã, operator= - de douã ori, destructor – de douã ori;",
      "constructor – de douã ori, constructor de copiere – o datã, operator= - de douã ori, destructor – de patru ori."
    ],
    "correct_answers": [3]
  }
]
